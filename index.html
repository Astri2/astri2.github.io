<!DOCTYPE html>
<html lang="en">
	<head>
		<title>CAVE simulator</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			CAVE Simulator. The head and teapot are draggable. <br />
			"L" See from Left Eye | "R" See from Right Eye | "S" toggle show scene  | "V" toggle VR eyes usage<br />
		</div>

		<script type="module">

			import * as THREE from 'three';

			import { TeapotGeometry } from 'three/examples/jsm/geometries/TeapotGeometry.js';
			import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
			import { DragControls } from 'three/examples/jsm/controls/DragControls.js';

			import { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';
			import { XRButton } from 'three/addons/webxr/XRButton.js';
			import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

			var models;
			var displaySurfaces, displaySurfaceGroup, displaySurfaceTargets;
			var eyeGroup, eyeCenter;
			var orbitControl, controls;
			var showScene = false, useVReyes = true;
			const prevButtonStates = new Map();

			let container;
			let camera, scene, raycaster, renderer;

			let room;

			let controller, controllerGrip;
			let INTERSECTED;

			class DisplaySurface 
			{
				constructor(name, origin, u_vector, v_vector) 
				{
					this.name = name;
					this.origin = origin;
					this.u = u_vector;
					this.v = v_vector;
				}

				viewMatrix(eye)
				{
					// to be written by you!
					var n = new THREE.Vector3().crossVectors(this.u, this.v).normalize();
					var target = new THREE.Vector3().subVectors(eye, n);
					var upVector = new THREE.Vector3(0,1,0);	
					
					var mat = new THREE.Matrix4();
					mat = mat.lookAt(eye, target, upVector); // this lookAt version creates only a rotation matrix
					var translate = new THREE.Matrix4().makeTranslation(-eye.x, -eye.y, -eye.z);
					mat = mat.multiplyMatrices(mat, translate);
					return mat;
				}
				
				projectionMatrix(eye, znear, zfar)
				{
					// to be written by you!
					var n = new THREE.Vector3().crossVectors(this.u, this.v).normalize(); 
					var d = -n.dot(new THREE.Vector3().subVectors(this.origin,eye));

					var uDir = this.u.clone().normalize();
					var vDir = this.v.clone().normalize();
					
					var lprim = new THREE.Vector3().subVectors(this.origin, eye).dot(uDir);        
					var rprim = new THREE.Vector3().addVectors(this.origin, this.u).sub(eye).dot(uDir);        
					var bprim = new THREE.Vector3().subVectors(this.origin, eye).dot(vDir);
					var tprim =  new THREE.Vector3().addVectors(this.origin, this.v).sub(eye).dot(vDir);

					var left = (lprim * znear)/d;
					var right = (rprim * znear)/d;
					var bottom = (bprim * znear)/d;
					var top = (tprim * znear)/d;
					
					return new THREE.Matrix4().makePerspective(left, right, top, bottom, znear, zfar);
				}
			}

			init();

			function createLights(group)
			{
				var ambientLight = new THREE.AmbientLight(0x888888, 0.4);
				group.add(ambientLight);
				var pointLight = new THREE.PointLight(0xffffff, 0.8);
				pointLight.position.z += 4;
				group.add(pointLight);
			}

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x505050 );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );
				camera.position.set( 0, 1.6, 3 );
				scene.add( camera );

				room = new THREE.LineSegments(
					new BoxLineGeometry( 6, 6, 6, 10, 10, 10 ).translate( 0, 3, 0 ),
					new THREE.LineBasicMaterial( { color: 0xbcbcbc } )
				);
				scene.add( room );

				createLights(scene)

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.xr.enabled = true;
				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize );

				document.body.appendChild( XRButton.createButton( renderer, {
					'optionalFeatures': [ 'depth-sensing' ],
					'depthSensing': { 'usagePreference': [ 'gpu-optimized' ], 'dataFormatPreference': [] }
				} ) );

			}

			function onKeyDown(event) {
				switch ( event.code ) {
				case 'KeyL': 
					var eye = getLeftEyePosition();
					camera.position.set(eye.x, eye.y, eye.z); 
					break;
					
				case 'KeyR': 
					var eye = getRightEyePosition();
					camera.position.set(eye.x, eye.y, eye.z); 
					break;
					
				case 'KeyS':
					showScene = !showScene;
					controls.enabled = showScene
					break;
					
				case 'KeyT':
					var viewF = displaySurfaces[0].viewMatrix(new THREE.Vector3(50,20,100));
					var viewL = displaySurfaces[1].viewMatrix(new THREE.Vector3(50,20,100));
					//var viewR = displaySurfaces[2].viewMatrix(new THREE.Vector3(50,20,100));
					//var viewB = displaySurfaces[3].viewMatrix(new THREE.Vector3(50,20,100));
					console.log("View matrices:");
					console.log(viewF);
					console.log(viewL);
					//console.log(viewR);
					//console.log(viewB);
					break;
					
				case 'KeyY':
					var projF = displaySurfaces[0].projectionMatrix(new THREE.Vector3(50,20,100), 0.1, 100);
					var projL = displaySurfaces[1].projectionMatrix(new THREE.Vector3(50,20,100), 0.1, 100);
					var projR = displaySurfaces[2].projectionMatrix(new THREE.Vector3(50,20,100), 0.1, 100);
					var projB = displaySurfaces[3].projectionMatrix(new THREE.Vector3(50,20,100), 0.1, 100);
					console.log("Projection matrices:");
					console.log(projF);
					console.log(projL);
					console.log(projR);
					console.log(projB);
					break;
				
				case 'KeyV':
					useVReyes = !useVReyes;
					break;
				}
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			//
			function getLeftEyePosition()
			{
				var eye = eyeGroup.getObjectByName("EyeL");
				return eye.getWorldPosition(new THREE.Vector3());
			}

			function getRightEyePosition()
			{
				var eye = eyeGroup.getObjectByName("EyeR");
				return eye.getWorldPosition(new THREE.Vector3());
			}

			function cameraFromViewProj(view, proj)
			{
				var cam = camera.clone();
				var inv = new THREE.Matrix4();
				inv.copy(view).invert();
				cam.position.set(inv.elements[12], inv.elements[13], inv.elements[14]);
				cam.setRotationFromMatrix(view);
				cam.projectionMatrix = proj.clone();
				return cam;
			}

			function handleVRControllerButton(buttonId, source) {
				if(source.handedness == "right") {
					switch(buttonId) {
						case 4: useVReyes = !useVReyes; break;
						case 5: showScene = !showScene; break;
					}
				}
			}

			function animate() {

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
