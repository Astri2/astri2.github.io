<!DOCTYPE html>
<html lang="en">
	<head>
		<title>CAVE simulator</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			CAVE Simulator. The head and teapot are draggable. <br />
			"L" See from Left Eye | "R" See from Right Eye | "S" toggle show scene  | "V" toggle VR eyes usage (XR simulator)<br />
			"-" and "+" to move the eyes or rescale the selected object<br />
			On XR Controller: "A" toggle VR eyes usage | "B" toggle show scene
		</div>

		<script type="module">

			import * as THREE from 'three';

			import { TeapotGeometry } from 'three/examples/jsm/geometries/TeapotGeometry.js';
			import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
			import { DragControls } from 'three/examples/jsm/controls/DragControls.js';

			import { BoxLineGeometry } from 'three/addons/geometries/BoxLineGeometry.js';
			import { XRButton } from 'three/addons/webxr/XRButton.js';
			import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

			import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

			var models, notModels;
			var displaySurfaces, displaySurfaceGroup, displaySurfaceTargets;
			var eyeGroup, eyeCenter;
			var orbitControl, controls;
			var showScene = false, useVReyes = true;
			const prevButtonStates = new Map();

			let container;
			let camera, scene, raycaster, renderer;

			let room;

			let controller, controllerGrip;
			let INTERSECTED;

			var selectedObj = null;

			class DisplaySurface 
			{
				constructor(name, origin, u_vector, v_vector) 
				{
					this.name = name;
					this.origin = origin;
					this.u = u_vector;
					this.v = v_vector;
				}

				viewMatrix(eye)
				{
					// to be written by you!
					var n = new THREE.Vector3().crossVectors(this.u, this.v).normalize();
					var target = new THREE.Vector3().subVectors(eye, n);
					var upVector = new THREE.Vector3(0,1,0);	
					
					var mat = new THREE.Matrix4();
					mat = mat.lookAt(eye, target, upVector); // this lookAt version creates only a rotation matrix
					var translate = new THREE.Matrix4().makeTranslation(-eye.x, -eye.y, -eye.z);
					mat = mat.multiplyMatrices(mat, translate);
					return mat;
				}
				
				projectionMatrix(eye, znear, zfar)
				{
					// to be written by you!
					var n = new THREE.Vector3().crossVectors(this.u, this.v).normalize(); 
					var d = -n.dot(new THREE.Vector3().subVectors(this.origin,eye));

					var uDir = this.u.clone().normalize();
					var vDir = this.v.clone().normalize();
					
					var lprim = new THREE.Vector3().subVectors(this.origin, eye).dot(uDir);        
					var rprim = new THREE.Vector3().addVectors(this.origin, this.u).sub(eye).dot(uDir);        
					var bprim = new THREE.Vector3().subVectors(this.origin, eye).dot(vDir);
					var tprim =  new THREE.Vector3().addVectors(this.origin, this.v).sub(eye).dot(vDir);

					var left = (lprim * znear)/d;
					var right = (rprim * znear)/d;
					var bottom = (bprim * znear)/d;
					var top = (tprim * znear)/d;
					
					return new THREE.Matrix4().makePerspective(left, right, top, bottom, znear, zfar);
				}
			}

			init();

			function createLights(scene)
			{
				// Lights
				const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
				//hemiLight.position.set(0, 20, 0);
				scene.add(hemiLight);

				const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
				dirLight.position.set(1,1,1); //5, 10, 7.5
				dirLight.castShadow = true;
				scene.add(dirLight);
			}

			function clampEyesPos()
			{
				var eyeL = eyeGroup.getObjectByName("EyeL");
				var eyeR = eyeGroup.getObjectByName("EyeR");
				eyeL.position.x = THREE.MathUtils.clamp(eyeL.position.x, -0.64, -0.068);
				eyeL.position.y = 0.2;
				eyeL.position.z = -0.12;
				eyeR.position.x = THREE.MathUtils.clamp(eyeR.position.x, 0.068, 0.64);
				eyeR.position.y = 0.2;
				eyeR.position.z = -0.12;
			}

			function addDragControlToObjects()
			{
				
				var objects = models.children.slice();
				objects.push(eyeGroup.getObjectByName("Head"));
									
				controls = new DragControls( objects, camera, renderer.domElement );
				controls.addEventListener( 'hoveron', function ( event ) 
					{
						orbitControl.enabled = false;
					} );
				controls.addEventListener( 'hoveroff', function ( event ) 
					{
							orbitControl.enabled = true;
					} );
				controls.addEventListener( 'dragstart', function ( event ) 
					{
						event.object.material.emissive.set( 0xaaaaaa );
						selectedObj = event.object;
					} );
				controls.addEventListener( 'dragend', function ( event ) 
					{
						event.object.material.emissive.set( 0x000000 );
						selectedObj = null;
					} );
				controls.enabled = showScene
			}

			function loadGLTF(url) {
				return new Promise((resolve, reject) => {
					new GLTFLoader().load(url, gltf => resolve(gltf.scene), undefined, err => reject(err));
				});
			}

			async function createScene()
			{
				models = new THREE.Group();
				// createLights(modelsScene)

				var geometry = new TeapotGeometry(0.8, 15);
				var material = new THREE.MeshStandardMaterial( { color: 0xffffff } );
				var teapot = new THREE.Mesh(geometry, material);
				teapot.name = "Teapot";
				teapot.position.z-=1.4;
				models.add( teapot );

				
				const duck = await loadGLTF("https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF/Duck.gltf");
				duck.scale.set(0.4,0.4,0.4);

				const yellowDuck = duck.clone();
				yellowDuck.name = "yellowDuck";
				yellowDuck.position.set(2, 1, -1); 
				models.add(yellowDuck);

				const redDuck = duck.clone();
				redDuck.name = "redDuck";
				redDuck.traverse((child) => {
					if (child.isMesh) {
						child.material = child.material.clone(); 
						child.material.color.set(0xd20103);
					}
				});
				redDuck.position.set(-2, -2, 0.8); 
				models.add(redDuck);

				const greenDuck = duck.clone();
				greenDuck.name = "greenDuck";
				greenDuck.traverse((child) => {
					if (child.isMesh) {
						child.material = child.material.clone(); 
						child.material.color.set(0x00da00);  
					}
				});
				greenDuck.position.set(2, -2, 0.8); 
				models.add(greenDuck);

				scene.add(models);
				addDragControlToObjects();
			}

			
			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x505050 );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.01, 1000 );
				camera.position.set( 0.2, 0.2, 0.6 );
				camera.lookAt( 0, 0, 0 );
				scene.add( camera );

				room = new THREE.LineSegments(
					new BoxLineGeometry( 6, 6, 6, 10, 10, 10 ).translate( 0, 0, 0 ),
					new THREE.LineBasicMaterial( { color: 0xbcbcbc } )
				);
				notModels = new THREE.Group()
				scene.add(notModels)
				notModels.add( room );

				createLights(scene)

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.xr.enabled = true;

				container.appendChild( renderer.domElement );

				// CAVE INIT
				// createDisplaySurfaces();
				{
					var side = 6.00;
					var half = side / 2.0;

					displaySurfaces = [];
					// FRONT SCREEN
					var frontScreen = new DisplaySurface("Front", 
						new THREE.Vector3(-half, -half, -half), 
						new THREE.Vector3( side,  0.0,   0.0), 
						new THREE.Vector3( 0.0,   side,  0.0));
					displaySurfaces.push(frontScreen);

					// LEFT SCREEN
					var leftScreen = new DisplaySurface("Left",
						new THREE.Vector3(-half, -half,  half), 
						new THREE.Vector3( 0.0,   0.0,  -side), 
						new THREE.Vector3( 0.0,   side,  0.0));
					displaySurfaces.push(leftScreen);

					// RIGHT SCREEN
					var rightScreen = new DisplaySurface("Right",
						new THREE.Vector3( half, -half, -half), 
						new THREE.Vector3( 0.0,   0.0,   side),
						new THREE.Vector3( 0.0,   side,  0.0));
					displaySurfaces.push(rightScreen);

					// Floor SCREEN
					var floorScreen = new DisplaySurface("Floor",
						new THREE.Vector3(-half, -half,  half), 
						new THREE.Vector3( side,  0.0,   0.0),
						new THREE.Vector3( 0.0,   0.0,  -side));
					displaySurfaces.push(floorScreen);
				}

				// createDisplaySurfaceTargets();
				{
					const SIZE = 1024;  // texture resolution
					displaySurfaceTargets = [];
				
					for (var v of displaySurfaces)       
						displaySurfaceTargets.push(new THREE.WebGLRenderTarget(SIZE, SIZE));
				}
				

				// createDisplaySurfaceScene();
				{
					displaySurfaceGroup = new THREE.Group();

					// add display surfaces	
					for (var [index, displaySurface] of displaySurfaces.entries())
					{
						var origin = displaySurface.origin;
						var u = displaySurface.u;
						var v = displaySurface.v;
				
						geometry = new THREE.BoxGeometry(u.length(), v.length(), 0.01);
						var material = new THREE.MeshStandardMaterial( {map: displaySurfaceTargets[index].texture} );
						var cube = new THREE.Mesh( geometry, material );
						cube.name = displaySurface.name;
						if (displaySurface.name == "Left")
							cube.rotation.y = Math.PI / 2;
					
						if (displaySurface.name == "Right")
							cube.rotation.y = - Math.PI / 2;
							
						if (displaySurface.name == "Floor")
						{
							cube.rotation.x =  Math.PI / 2;
							cube.rotation.z =  Math.PI ;
						}
					
						var uHalf = u.clone().multiplyScalar(0.5);
						var vHalf = v.clone().multiplyScalar(0.5);
						var center = new THREE.Vector3().addVectors(origin, uHalf);
						center.add(vHalf);
						cube.position.set(center.x, center.y, center.z);
						
						// NEW
						// displaySurfaceScene.add(cube);
						displaySurfaceGroup.add(cube);
					}
					
					//createLights(displaySurfaceGroup);
					notModels.add(displaySurfaceGroup);
				}
				
				// createEyeScene();
				{
					var IPD = 0.136; 
					eyeCenter = new THREE.Vector3(1, 0.4, 1);
					// eye positions relative to the head
					var eyeL = new THREE.Vector3( - IPD/2, 0.2, -0.12);
					var eyeR = new THREE.Vector3( + IPD/2, 0.2, -0.12);
					
					eyeGroup = new THREE.Group();

					// add sphere representing head
					var geometry = new THREE.SphereGeometry( 0.2, 32, 22 );
					var material = new THREE.MeshStandardMaterial( { color: 0xaaaaaa } );
					var head = new THREE.Mesh( geometry, material );
					head.name = "Head";
					head.position.set(eyeCenter.x, eyeCenter.y, eyeCenter.z);
					eyeGroup.add(head);

					// add spheres representing L/R eyes
					var geometry = new THREE.SphereGeometry( 0.06, 32, 22 );
					var material = new THREE.MeshStandardMaterial( { color: 0xff0000 } );
					var sphere = new THREE.Mesh( geometry, material );
					sphere.name = "EyeL";
					sphere.position.set(eyeL.x, eyeL.y, eyeL.z);
					head.add(sphere);
					
					var geometry = new THREE.SphereGeometry( 0.06, 32, 22 );
					var material = new THREE.MeshStandardMaterial( { color: 0x0000ff } );
					var sphere = new THREE.Mesh( geometry, material );
					sphere.name = "EyeR";
					sphere.position.set(eyeR.x, eyeR.y, eyeR.z);
					head.add(sphere);
					
					notModels.add(eyeGroup);
				}

				createScene();

				// enableOrbitCamera();
				{
					orbitControl = new OrbitControls(camera, renderer.domElement );
					orbitControl.minDistance = 2.4;
					orbitControl.maxDistance = 1000;
				}


				renderer.xr.addEventListener('sessionstart', () => { 
					orbitControl.enabled = false; 
					controls.enabled = false;
				});
				renderer.xr.addEventListener('sessionend', () => { 
					orbitControl.enabled = true; 
					controls.enabled = true;
				});

				// Track controllers
				const controllers = [];
				function setupController(index) {
					const controller = renderer.xr.getController(index);
					scene.add(controller);
					controllers.push(controller);
				}
				setupController(0);
				setupController(1);

				window.addEventListener( 'resize', onWindowResize );
				window.addEventListener( 'keydown', onKeyDown);

				document.body.appendChild( XRButton.createButton( renderer, {
					'optionalFeatures': [ 'depth-sensing' ],
					'depthSensing': { 'usagePreference': [ 'gpu-optimized' ], 'dataFormatPreference': [] }
				} ) );

			}

			function onKeyDown(event) {
				switch ( event.code ) {
				case 'KeyL': 
					var eye = getLeftEyePosition();
					camera.position.set(eye.x, eye.y, eye.z); 
					break;
					
				case 'KeyR': 
					var eye = getRightEyePosition();
					camera.position.set(eye.x, eye.y, eye.z); 
					break;
					
				case 'KeyS':
					showScene = !showScene;
					controls.enabled = showScene
					break;
					
				case 'KeyT':
					var viewF = displaySurfaces[0].viewMatrix(new THREE.Vector3(50,20,100));
					var viewL = displaySurfaces[1].viewMatrix(new THREE.Vector3(50,20,100));
					var viewR = displaySurfaces[2].viewMatrix(new THREE.Vector3(50,20,100));
					var viewB = displaySurfaces[3].viewMatrix(new THREE.Vector3(50,20,100));
					console.log("View matrices:");
					console.log(viewF);
					console.log(viewL);
					console.log(viewR);
					console.log(viewB);
					break;
					
				case 'KeyY':
					var projF = displaySurfaces[0].projectionMatrix(new THREE.Vector3(50,20,100), 0.1, 100);
					var projL = displaySurfaces[1].projectionMatrix(new THREE.Vector3(50,20,100), 0.1, 100);
					var projR = displaySurfaces[2].projectionMatrix(new THREE.Vector3(50,20,100), 0.1, 100);
					var projB = displaySurfaces[3].projectionMatrix(new THREE.Vector3(50,20,100), 0.1, 100);
					console.log("Projection matrices:");
					console.log(projF);
					console.log(projL);
					console.log(projR);
					console.log(projB);
					break;
				
				case 'KeyV':
					useVReyes = !useVReyes;
					break;

				case 'Equal':
					if(selectedObj == null){
						var eyeL = eyeGroup.getObjectByName("EyeL");
						var eyeR = eyeGroup.getObjectByName("EyeR");
						eyeL.position.x -= 1/50;
						eyeR.position.x += 1/50;

						clampEyesPos();
					}else{
						selectedObj.scale.multiplyScalar(1.1);
					}
                
                break; 
                
            	case 'Minus':
					if(selectedObj == null){
						var eyeL = eyeGroup.getObjectByName("EyeL");
						var eyeR = eyeGroup.getObjectByName("EyeR");
						eyeL.position.x += 1/50;
						eyeR.position.x -= 1/50;
						clampEyesPos();
					}else{
						selectedObj.scale.multiplyScalar(1/1.1);                    
					}
					break;
				}
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			//
			function getLeftEyePosition()
			{
				var eye = eyeGroup.getObjectByName("EyeL");
				return eye.getWorldPosition(new THREE.Vector3());
			}

			function getRightEyePosition()
			{
				var eye = eyeGroup.getObjectByName("EyeR");
				return eye.getWorldPosition(new THREE.Vector3());
			}

			function cameraFromViewProj(view, proj)
			{
				var cam = camera.clone();
				var inv = new THREE.Matrix4();
				inv.copy(view).invert();
				cam.position.set(inv.elements[12], inv.elements[13], inv.elements[14]);
				cam.setRotationFromMatrix(view);
				cam.projectionMatrix = proj.clone();
				return cam;
			}

			function handleVRControllerButton(buttonId, source) {
				if(source.handedness == "right") {
					switch(buttonId) {
						case 4: useVReyes = !useVReyes; break;
						case 5: showScene = !showScene; break;
					}
				}
			}

			function animate() {
				// camera depends on xr usage
				const xrActive = renderer.xr.isPresenting;
  				const sceneCam = xrActive ? renderer.xr.getCamera(camera) : camera;
				
				// get eyes coordinates
				var eyeL;
				var eyeR;
				if(xrActive && useVReyes) {
					// xr stereo
					if (sceneCam.cameras && sceneCam.cameras.length >= 2) {
						eyeL = new THREE.Vector3().setFromMatrixPosition(sceneCam.cameras[0].matrixWorld);
						eyeR = new THREE.Vector3().setFromMatrixPosition(sceneCam.cameras[1].matrixWorld);
					// xr mono
					} else {
						eyeL = new THREE.Vector3().setFromMatrixPosition(sceneCam.matrixWorld);
            			eyeR = eyeL.clone();
					}
				} else {
					// no xr (orbit cam)
					eyeL = getLeftEyePosition();
					eyeR = getRightEyePosition();
				}

				// render to the walls
				const gl = renderer.getContext();
				const prevXrEnabled = renderer.xr.enabled; 
				// must disabled xr to allow multi rendering
				renderer.xr.enabled = false;
				notModels.visible = false;
				for (let [index, displaySurface] of displaySurfaces.entries()) {
					renderer.setRenderTarget(displaySurfaceTargets[index]);
					renderer.setClearColor(0x404040);
					renderer.clear();

					// Left eye -> RED
					gl.colorMask(true, false, false, true);
					const viewL = displaySurface.viewMatrix(eyeL);
					const projL = displaySurface.projectionMatrix(eyeL, 0.2, 200);
					const camL = cameraFromViewProj(viewL, projL);
					
					renderer.render(scene, camL);

					// Right eye -> GREEN + BLUE
					gl.colorMask(false, true, true, true);
					const viewR = displaySurface.viewMatrix(eyeR);
					const projR = displaySurface.projectionMatrix(eyeR, 0.2, 200);
					const camR = cameraFromViewProj(viewR, projR);
					renderer.clearDepth();
					
					renderer.render(scene, camR);

					gl.colorMask(true, true, true, true);
				}
				notModels.visible = true;

				// Restore XR state 
				renderer.xr.enabled = prevXrEnabled;

				// Restore target and clear
				renderer.setRenderTarget(null);
				renderer.setClearColor(0x000000);
				
				// if you don't want to render the models, disabled them temporarly
				if(!showScene) {
					models.visible = false;
					eyeGroup.visible = false;
				}
				renderer.render( scene, sceneCam );
				models.visible = true;
				eyeGroup.visible = true;

				// read VR controllers buttons
				const session = renderer.xr.getSession();
				if (session) {
					for (const source of session.inputSources) {
						if (source && source.gamepad) {
							const gp = source.gamepad;
							
							// Get previous states for this controller
        					let prev = prevButtonStates.get(source) || gp.buttons.map(() => ({ pressed: false }));
							gp.buttons.forEach((btn, i) => {
								if (btn.pressed && !prev[i].pressed) {
									handleVRControllerButton(i, source);
									// console.log("Button", i, "pressed on controller " + source.handedness);
								}
							});
							// Save current state for next frame
							prevButtonStates.set(source, gp.buttons.map(b => ({ pressed: b.pressed })));
						}
					}
				}
			}

		</script>
	</body>
</html>