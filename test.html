const animate = function () {
  
  // If XR is active, get the per-eye world positions from xrCamera.cameras
  let realEyeL = null;
  let realEyeR = null;
  if (xrActive) {
    const xrCam = renderer.xr.getCamera(camera);
    // xrCam.cameras is an array of sub-cameras (one per view)
    // Usually 0 = left, 1 = right, but verify length
    if (xrCam.cameras && xrCam.cameras.length >= 2) {
      realEyeL = new THREE.Vector3().setFromMatrixPosition(xrCam.cameras[0].matrixWorld);
      realEyeR = new THREE.Vector3().setFromMatrixPosition(xrCam.cameras[1].matrixWorld);
    } else {
      // fallback to viewer position if not available
      realEyeL = new THREE.Vector3().setFromMatrixPosition(xrCam.matrixWorld);
      realEyeR = realEyeL.clone();
    }

    // Optionally update your debug head/eyes to follow the real headset
    const head = eyeScene.getObjectByName("Head");
    if (head) head.position.copy(new THREE.Vector3().addVectors(realEyeL, realEyeR).multiplyScalar(0.5));
    const eL = eyeScene.getObjectByName("EyeL");
    const eR = eyeScene.getObjectByName("EyeR");
    if (eL) eL.getWorldPosition(new THREE.Vector3()); // ensure world transforms are OK
    if (eL) eL.position.copy(realEyeL.clone().sub(head.position));
    if (eR) eR.position.copy(realEyeR.clone().sub(head.position));
  }



  for (const [index, displaySurface] of displaySurfaces.entries()) {
    renderer.setRenderTarget(displaySurfaceTargets[index]);
    renderer.setClearColor(0x404040);
    renderer.clear();

    // For left eye: use realEyeL if available, else fallback to your eyeScene positions
    const eyeLpos = realEyeL ? realEyeL : getLeftEyePosition();
    const viewL = displaySurface.viewMatrix(eyeLpos);
    const projL = displaySurface.projectionMatrix(eyeLpos, 1, 10000);
    gl.colorMask(true, false, false, false);
    {
      const camL = cameraFromViewProj(viewL, projL);
      renderer.render(scene, camL);
    }

    // For right eye: use realEyeR if available
    const eyeRpos = realEyeR ? realEyeR : getRightEyePosition();
    const viewR = displaySurface.viewMatrix(eyeRpos);
    const projR = displaySurface.projectionMatrix(eyeRpos, 1, 10000);
    gl.colorMask(false, true, true, false);
    {
      const camR = cameraFromViewProj(viewR, projR);
      renderer.clearDepth();
      renderer.render(scene, camR);
    }

    gl.colorMask(true, true, true, true);
  }