{
  "version": 3,
  "sources": ["../../three/examples/jsm/controls/DragControls.js"],
  "sourcesContent": ["import {\r\n\tControls,\r\n\tMatrix4,\r\n\tPlane,\r\n\tRaycaster,\r\n\tVector2,\r\n\tVector3,\r\n\tMOUSE,\r\n\tTOUCH\r\n} from 'three';\r\n\r\nconst _plane = new Plane();\r\n\r\nconst _pointer = new Vector2();\r\nconst _offset = new Vector3();\r\nconst _diff = new Vector2();\r\nconst _previousPointer = new Vector2();\r\nconst _intersection = new Vector3();\r\nconst _worldPosition = new Vector3();\r\nconst _inverseMatrix = new Matrix4();\r\n\r\nconst _up = new Vector3();\r\nconst _right = new Vector3();\r\n\r\nlet _selected = null, _hovered = null;\r\nconst _intersections = [];\r\n\r\nconst STATE = {\r\n\tNONE: - 1,\r\n\tPAN: 0,\r\n\tROTATE: 1\r\n};\r\n\r\n/**\r\n * This class can be used to provide a drag'n'drop interaction.\r\n *\r\n * ```js\r\n * const controls = new DragControls( objects, camera, renderer.domElement );\r\n *\r\n * // add event listener to highlight dragged objects\r\n * controls.addEventListener( 'dragstart', function ( event ) {\r\n *\r\n * \tevent.object.material.emissive.set( 0xaaaaaa );\r\n *\r\n * } );\r\n *\r\n * controls.addEventListener( 'dragend', function ( event ) {\r\n *\r\n * \tevent.object.material.emissive.set( 0x000000 );\r\n *\r\n * } );\r\n * ```\r\n *\r\n * @augments Controls\r\n * @three_import import { DragControls } from 'three/addons/controls/DragControls.js';\r\n */\r\nclass DragControls extends Controls {\r\n\r\n\t/**\r\n\t * Constructs a new controls instance.\r\n\t *\r\n\t * @param {Array<Object3D>} objects - An array of draggable 3D objects.\r\n\t * @param {Camera} camera - The camera of the rendered scene.\r\n\t * @param {?HTMLElement} [domElement=null] - The HTML DOM element used for event listeners.\r\n\t */\r\n\tconstructor( objects, camera, domElement = null ) {\r\n\r\n\t\tsuper( camera, domElement );\r\n\r\n\t\t/**\r\n\t\t * An array of draggable 3D objects.\r\n\t\t *\r\n\t\t * @type {Array<Object3D>}\r\n\t\t */\r\n\t\tthis.objects = objects;\r\n\r\n\t\t/**\r\n\t\t * Whether children of draggable objects can be dragged independently from their parent.\r\n\t\t *\r\n\t\t * @type {boolean}\r\n\t\t * @default true\r\n\t\t */\r\n\t\tthis.recursive = true;\r\n\r\n\t\t/**\r\n\t\t * This option only works if the `objects` array contains a single draggable  group object.\r\n\t\t * If set to `true`, the controls does not transform individual objects but the entire group.\r\n\t\t *\r\n\t\t * @type {boolean}\r\n\t\t * @default false\r\n\t\t */\r\n\t\tthis.transformGroup = false;\r\n\r\n\t\t/**\r\n\t\t * The speed at which the object will rotate when dragged in `rotate` mode.\r\n\t\t * The higher the number the faster the rotation.\r\n\t\t *\r\n\t\t * @type {number}\r\n\t\t * @default 1\r\n\t\t */\r\n\t\tthis.rotateSpeed = 1;\r\n\r\n\t\t/**\r\n\t\t * The raycaster used for detecting 3D objects.\r\n\t\t *\r\n\t\t * @type {Raycaster}\r\n\t\t */\r\n\t\tthis.raycaster = new Raycaster();\r\n\r\n\t\t// interaction\r\n\r\n\t\tthis.mouseButtons = { LEFT: MOUSE.PAN, MIDDLE: MOUSE.PAN, RIGHT: MOUSE.ROTATE };\r\n\t\tthis.touches = { ONE: TOUCH.PAN };\r\n\r\n\t\t// event listeners\r\n\r\n\t\tthis._onPointerMove = onPointerMove.bind( this );\r\n\t\tthis._onPointerDown = onPointerDown.bind( this );\r\n\t\tthis._onPointerCancel = onPointerCancel.bind( this );\r\n\t\tthis._onContextMenu = onContextMenu.bind( this );\r\n\r\n\t\t//\r\n\r\n\t\tif ( domElement !== null ) {\r\n\r\n\t\t\tthis.connect( domElement );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tconnect( element ) {\r\n\r\n\t\tsuper.connect( element );\r\n\r\n\t\tthis.domElement.addEventListener( 'pointermove', this._onPointerMove );\r\n\t\tthis.domElement.addEventListener( 'pointerdown', this._onPointerDown );\r\n\t\tthis.domElement.addEventListener( 'pointerup', this._onPointerCancel );\r\n\t\tthis.domElement.addEventListener( 'pointerleave', this._onPointerCancel );\r\n\t\tthis.domElement.addEventListener( 'contextmenu', this._onContextMenu );\r\n\r\n\t\tthis.domElement.style.touchAction = 'none'; // disable touch scroll\r\n\r\n\t}\r\n\r\n\tdisconnect() {\r\n\r\n\t\tthis.domElement.removeEventListener( 'pointermove', this._onPointerMove );\r\n\t\tthis.domElement.removeEventListener( 'pointerdown', this._onPointerDown );\r\n\t\tthis.domElement.removeEventListener( 'pointerup', this._onPointerCancel );\r\n\t\tthis.domElement.removeEventListener( 'pointerleave', this._onPointerCancel );\r\n\t\tthis.domElement.removeEventListener( 'contextmenu', this._onContextMenu );\r\n\r\n\t\tthis.domElement.style.touchAction = 'auto';\r\n\t\tthis.domElement.style.cursor = '';\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis.disconnect();\r\n\r\n\t}\r\n\r\n\t_updatePointer( event ) {\r\n\r\n\t\tconst rect = this.domElement.getBoundingClientRect();\r\n\r\n\t\t_pointer.x = ( event.clientX - rect.left ) / rect.width * 2 - 1;\r\n\t\t_pointer.y = - ( event.clientY - rect.top ) / rect.height * 2 + 1;\r\n\r\n\t}\r\n\r\n\t_updateState( event ) {\r\n\r\n\t\t// determine action\r\n\r\n\t\tlet action;\r\n\r\n\t\tif ( event.pointerType === 'touch' ) {\r\n\r\n\t\t\taction = this.touches.ONE;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tswitch ( event.button ) {\r\n\r\n\t\t\t\tcase 0:\r\n\r\n\t\t\t\t\taction = this.mouseButtons.LEFT;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 1:\r\n\r\n\t\t\t\t\taction = this.mouseButtons.MIDDLE;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 2:\r\n\r\n\t\t\t\t\taction = this.mouseButtons.RIGHT;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\taction = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// determine state\r\n\r\n\t\tswitch ( action ) {\r\n\r\n\t\t\tcase MOUSE.PAN:\r\n\t\t\tcase TOUCH.PAN:\r\n\r\n\t\t\t\tthis.state = STATE.PAN;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase MOUSE.ROTATE:\r\n\t\t\tcase TOUCH.ROTATE:\r\n\r\n\t\t\t\tthis.state = STATE.ROTATE;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tthis.state = STATE.NONE;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction onPointerMove( event ) {\r\n\r\n\tconst camera = this.object;\r\n\tconst domElement = this.domElement;\r\n\tconst raycaster = this.raycaster;\r\n\r\n\tif ( this.enabled === false ) return;\r\n\r\n\tthis._updatePointer( event );\r\n\r\n\traycaster.setFromCamera( _pointer, camera );\r\n\r\n\tif ( _selected ) {\r\n\r\n\t\tif ( this.state === STATE.PAN ) {\r\n\r\n\t\t\tif ( raycaster.ray.intersectPlane( _plane, _intersection ) ) {\r\n\r\n\t\t\t\t_selected.position.copy( _intersection.sub( _offset ).applyMatrix4( _inverseMatrix ) );\r\n\t\t\t\tthis.dispatchEvent( { type: 'drag', object: _selected } );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( this.state === STATE.ROTATE ) {\r\n\r\n\t\t\t_diff.subVectors( _pointer, _previousPointer ).multiplyScalar( this.rotateSpeed );\r\n\t\t\t_selected.rotateOnWorldAxis( _up, _diff.x );\r\n\t\t\t_selected.rotateOnWorldAxis( _right.normalize(), - _diff.y );\r\n\t\t\tthis.dispatchEvent( { type: 'drag', object: _selected } );\r\n\r\n\t\t}\r\n\r\n\t\t_previousPointer.copy( _pointer );\r\n\r\n\t} else {\r\n\r\n\t\t// hover support\r\n\r\n\t\tif ( event.pointerType === 'mouse' || event.pointerType === 'pen' ) {\r\n\r\n\t\t\t_intersections.length = 0;\r\n\r\n\t\t\traycaster.setFromCamera( _pointer, camera );\r\n\t\t\traycaster.intersectObjects( this.objects, this.recursive, _intersections );\r\n\r\n\t\t\tif ( _intersections.length > 0 ) {\r\n\r\n\t\t\t\tconst object = _intersections[ 0 ].object;\r\n\r\n\t\t\t\t_plane.setFromNormalAndCoplanarPoint( camera.getWorldDirection( _plane.normal ), _worldPosition.setFromMatrixPosition( object.matrixWorld ) );\r\n\r\n\t\t\t\tif ( _hovered !== object && _hovered !== null ) {\r\n\r\n\t\t\t\t\tthis.dispatchEvent( { type: 'hoveroff', object: _hovered } );\r\n\r\n\t\t\t\t\tdomElement.style.cursor = 'auto';\r\n\t\t\t\t\t_hovered = null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( _hovered !== object ) {\r\n\r\n\t\t\t\t\tthis.dispatchEvent( { type: 'hoveron', object: object } );\r\n\r\n\t\t\t\t\tdomElement.style.cursor = 'pointer';\r\n\t\t\t\t\t_hovered = object;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( _hovered !== null ) {\r\n\r\n\t\t\t\t\tthis.dispatchEvent( { type: 'hoveroff', object: _hovered } );\r\n\r\n\t\t\t\t\tdomElement.style.cursor = 'auto';\r\n\t\t\t\t\t_hovered = null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_previousPointer.copy( _pointer );\r\n\r\n}\r\n\r\nfunction onPointerDown( event ) {\r\n\r\n\tconst camera = this.object;\r\n\tconst domElement = this.domElement;\r\n\tconst raycaster = this.raycaster;\r\n\r\n\tif ( this.enabled === false ) return;\r\n\r\n\tthis._updatePointer( event );\r\n\tthis._updateState( event );\r\n\r\n\t_intersections.length = 0;\r\n\r\n\traycaster.setFromCamera( _pointer, camera );\r\n\traycaster.intersectObjects( this.objects, this.recursive, _intersections );\r\n\r\n\tif ( _intersections.length > 0 ) {\r\n\r\n\t\tif ( this.transformGroup === true ) {\r\n\r\n\t\t\t// look for the outermost group in the object's upper hierarchy\r\n\r\n\t\t\t_selected = findGroup( _intersections[ 0 ].object );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_selected = _intersections[ 0 ].object;\r\n\r\n\t\t}\r\n\r\n\t\t_plane.setFromNormalAndCoplanarPoint( camera.getWorldDirection( _plane.normal ), _worldPosition.setFromMatrixPosition( _selected.matrixWorld ) );\r\n\r\n\t\tif ( raycaster.ray.intersectPlane( _plane, _intersection ) ) {\r\n\r\n\t\t\tif ( this.state === STATE.PAN ) {\r\n\r\n\t\t\t\t_inverseMatrix.copy( _selected.parent.matrixWorld ).invert();\r\n\t\t\t\t_offset.copy( _intersection ).sub( _worldPosition.setFromMatrixPosition( _selected.matrixWorld ) );\r\n\t\t\t\tdomElement.style.cursor = 'move';\r\n\t\t\t\tthis.dispatchEvent( { type: 'dragstart', object: _selected } );\r\n\r\n\t\t\t} else if ( this.state === STATE.ROTATE ) {\r\n\r\n\t\t\t\t// the controls only support Y+ up\r\n\t\t\t\t_up.set( 0, 1, 0 ).applyQuaternion( camera.quaternion ).normalize();\r\n\t\t\t\t_right.set( 1, 0, 0 ).applyQuaternion( camera.quaternion ).normalize();\r\n\t\t\t\tdomElement.style.cursor = 'move';\r\n\t\t\t\tthis.dispatchEvent( { type: 'dragstart', object: _selected } );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_previousPointer.copy( _pointer );\r\n\r\n}\r\n\r\nfunction onPointerCancel() {\r\n\r\n\tif ( this.enabled === false ) return;\r\n\r\n\tif ( _selected ) {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dragend', object: _selected } );\r\n\r\n\t\t_selected = null;\r\n\r\n\t}\r\n\r\n\tthis.domElement.style.cursor = _hovered ? 'pointer' : 'auto';\r\n\r\n\tthis.state = STATE.NONE;\r\n\r\n}\r\n\r\nfunction onContextMenu( event ) {\r\n\r\n\tif ( this.enabled === false ) return;\r\n\r\n\tevent.preventDefault();\r\n\r\n}\r\n\r\nfunction findGroup( obj, group = null ) {\r\n\r\n\tif ( obj.isGroup ) group = obj;\r\n\r\n\tif ( obj.parent === null ) return group;\r\n\r\n\treturn findGroup( obj.parent, group );\r\n\r\n}\r\n\r\n/**\r\n * Fires when the user drags a 3D object.\r\n *\r\n * @event DragControls#drag\r\n * @type {Object}\r\n */\r\n\r\n/**\r\n * Fires when the user has finished dragging a 3D object.\r\n *\r\n * @event DragControls#dragend\r\n * @type {Object}\r\n */\r\n\r\n/**\r\n * Fires when the pointer is moved onto a 3D object, or onto one of its children.\r\n *\r\n * @event DragControls#hoveron\r\n * @type {Object}\r\n */\r\n\r\n/**\r\n * Fires when the pointer is moved out of a 3D object.\r\n *\r\n * @event DragControls#hoveroff\r\n * @type {Object}\r\n */\r\n\r\nexport { DragControls };\r\n"],
  "mappings": "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",
  "names": []
}
